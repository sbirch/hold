hold
====

**Have you ever thrown away long-running calculations because of an exception from matplotlib?**

This is a small Python module that makes it easier to save
and load the results of functions. It preserves the output of the
function in addition to the return value using cPickle.

### Documentation

This module has one important function, `hold`:

```
hold(func, args=(), kwargs={}, v=1, name=None)
```

`hold` returns the value of `func(*args, **kwargs)`, either by evaluating
`func` or by retrieving the value from cache on disk. If the result is
retrieved from cache, it will re-print the output generated by
the function.

* `func`: the function to call if no stored result is available.
* `args`: the arguments to the function, as a tuple.
* `kwargs`: keyword arguments to the function, as a dictionary.
* `v`: the version, a number or string. A new value invalidates the
cache. For example you would change the version number when you change `func`. If `v=None` the cache will always be passed (you might use this for development.)
* `name`: a unique ID for the function. If `None`, uses `func.__name__` (though
**this ID may collide**!).

Some examples:

```
from hold import hold

value = hold(really_long_func)

# Arguments are passed as a tuple, keyword arguments as a dictionary.
value = hold(really_long_func, (n,), {'x': 1})
```

If `really_long_func` has been run with the same arguments, version, and name
before the result will be loaded from disk. Otherwise the function will be run
and the result will be stored. Loading cached data speeds up development of code
which depends on earlier results (for example matplotlib charts on the results
of a long-running simulation.)

Rather than rely on magic to determine when your function has changed, hold
relies on you to change the version when you want the function to be
re-computed:

```
from hold import hold

value = hold('someid', really_long_func, v=2)
```

Typically you would use `hold` once the function you plan to cache has been
substantially written, so you shouldn't have to do this too often.

Older versions remain on disk &mdash; it can be useful to be able to load two seperate
versions of the data. But to delete old cached versions you can delete the files,
which start with `.HELD` in the working directory.



### Caveats:

* Currently the cache files are stored (and looked for) in the current working
directory when the script is run. Running the script from a different directory
will act like a fresh cache.

* This is backed by cPickle, so only functions with pickleable return values and arguments can be held. In some cases storing and loading a pickle can be slower than the original computation.

* On playback the `stdout` and `stderr` transcripts are both written to `stdout`.


### etc.

Run tests with `python setup.py test`.

`hold` also includes `filename(name, args, kwargs, v)`, which will return the name
of the cache file, and `Tee` which forks `stdout` to a `StringIO`.
